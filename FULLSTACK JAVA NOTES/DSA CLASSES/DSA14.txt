How to create a adjacent list using edges
=========================================
nodes =4, edges = [[0,2],[0,1],[1,3]];

Diagram: DSA14.1


import java.util.*;
class Graph 
{
	List<List<Integer>> adjList;
	public Graph(int nodes)
	{
		adjList = new ArrayList<>();
		for(int i=0;i<nodes;i++)
		{
			adjList.add(new ArrayList<>());
		}
	}
	public void addEdgesToList(int[][] edges,boolean isDirected)
	{
		for(int[] edge : edges)
		{
			int u = edge[0];
			int v = edge[1];
			if(isDirected)
			{
				adjList.get(u).add(v);
			}
			else
			{
				adjList.get(u).add(v);
				adjList.get(v).add(u);
			}
		}
	}
	public void printList()
	{
		for(int i=0;i<adjList.size();i++)
		{
			System.out.print("row "+i+" -> ");
			System.out.print("[");
			for(int j=0;j<adjList.get(i).size();j++)
			{
				System.out.print(adjList.get(i).get(j));
				if(j!=adjList.get(i).size()-1)
				{
					System.out.print(" , ");
				}
			}
			System.out.print("]");
			//new line 
			System.out.println();
		}
	}
}
class Test  
{
	public static void main(String[] args) 
	{
		int[][] edges = {{0,2},{0,1},{1,3}};
		int nodes=4;
		Graph graph = new Graph(nodes);
		graph.addEdgesToList(edges,true);
		graph.printList();
	}
}


How to create a adjacent list with weight using edges
=====================================================
nodes =4, edges = [[0,2,10],[0,1,20],[1,3,30]];

Diagram: DSA14.2


import java.util.*;
class Pair 
{
	int node;
	int weight;
	public Pair(int node,int weight)
	{
		this.node=node;
		this.weight=weight;
	}
	@Override
	public String toString()
	{
		return node+" "+weight;
	}
}
class Graph 
{
	List<List<Pair>> adjList;
	public Graph(int nodes)
	{
		adjList = new ArrayList<>();
		for(int i=0;i<nodes;i++)
		{
			adjList.add(new ArrayList<>());
		}
	}
	public void addEdgesToList(int[][] edges,boolean isDirected)
	{
		for(int[] edge : edges)
		{
			int u = edge[0];
			int v = edge[1];
			int w = edge[2];
			if(isDirected)
			{
				adjList.get(u).add(new Pair(v,w));
			}
			else
			{
				adjList.get(u).add(new Pair(v,w));
				adjList.get(v).add(new Pair(u,w));
			}
		}
	}
	public void printList()
	{
		for(int i=0;i<adjList.size();i++)
		{
			System.out.print("row "+i+" -> ");
			System.out.print("[");
			for(int j=0;j<adjList.get(i).size();j++)
			{
				System.out.print(adjList.get(i).get(j));
				if(j!=adjList.get(i).size()-1)
				{
					System.out.print(" , ");
				}
			}
			System.out.print("]");
			//new line 
			System.out.println();
		}
	}
}
class Test  
{
	public static void main(String[] args) 
	{
		int[][] edges = {{0,2,10},{0,1,20},{1,3,30}};
		int nodes=4;
		Graph graph = new Graph(nodes);
		graph.addEdgesToList(edges,true);
		graph.printList();
	}
}

DFS 
====
Depth-First Search (DFS) is a graph traversal algorithm that explores as far as possible along each branch before backtracking. It is commonly used for searching or traversing tree or graph data structures. 


Example :
---------
You are given a connected undirected graph . Perform Depth First Traversal of the graph.
Input:
	V=5, adj=[[2,3,1],[0],[0,4],[0],[2]];	

Diagram: DSA14.3

import java.util.*;

class Test  
{
	public static void main(String[] args) 
	{
		int V=5;
		List<List<Integer>> list = Arrays.asList(
					Arrays.asList(2,3,1),
					Arrays.asList(0),
					Arrays.asList(0,4),
					Arrays.asList(0),
					Arrays.asList(2)
				);
		List<Integer> newList = dfsOfGraph(V,list);	
		for(int i: newList)
		{
			System.out.print(i+" ");
		}
	}
	public static List<Integer> dfsOfGraph(int node,List<List<Integer>> list)
	{
		List<Integer> res = new ArrayList<>();
		boolean[] visited = new boolean[node];
		
		//logic for connected and disconnect graphs 
		for(int i=0;i<node;i++)
		{
			if(!visited[i])
			{
				dfs(i,visited,list,res);
			}
		}
		
		return res;
	}
	public static void dfs(int node,boolean[] visited,
		List<List<Integer>> list,List<Integer> res)
	{
		//current node 
		visited[node]=true;
		
		//add in the result list
		res.add(node);
		
		//check the neighbours
		for(int neighbours : list.get(node))
		{
			if(!visited[neighbours])
			{
				dfs(neighbours,visited,list,res);
			}
		}
	}
}


















