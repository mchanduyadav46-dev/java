Working with properties file 
============================
In regular intervals, DBA will change user and password for security reason.

It is never recommanded to pass database properties directly to an application.

It is always recommanded to read database properties from properties file.

A properties file contains key and value pair.

dbdetails.properties 
--------------------
driver=oracle.jdbc.driver.OracleDriver
url=jdbc:oracle:thin:@localhost:1521:XE
username=system
password=admin 

PropertiesApp.java
------------------
package com.ihub.www;

import java.io.FileInputStream;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.util.Properties;

public class PropertiesApp
{
	public static void main(String[] args)throws Exception  
	{
		//locate properties file
		FileInputStream fis = new FileInputStream("src/com/ihub/www/dbdetails.properties");
		
		//create Properties class
		Properties p = new Properties();
		
		//load the data from properties file 
		p.load(fis);
		
		//read the data from Properties class
		String s1 = p.getProperty("driver");
		String s2 = p.getProperty("url");
		String s3 = p.getProperty("username");
		String s4 = p.getProperty("password");
		
		Class.forName(s1);
		Connection con = DriverManager.getConnection(s2,s3,s4);
		Statement st = con.createStatement();
		String qry = "select * from student";
		ResultSet rs = st.executeQuery(qry);
		while(rs.next())
		{
			System.out.println(rs.getRow()+" "+rs.getInt(1)+" "+rs.getString(2)+" "+rs.getString(3));
		}
		rs.close();
		st.close();
		con.close();
	}
}

JDBC Flexible Application 
=========================
In JDBC, Connection object consider as heavy weight object.

It is never recommanded to create Connection object for every application.

It is recommanded to create a seperate class which returns Connection object.

DBConnection.java
-----------------
package com.ihub.www;

import java.sql.Connection;
import java.sql.DriverManager;

public class DBConnection 
{
	static Connection con = null;
	
	private DBConnection()
	{
	}
	
	public static Connection getConnection()
	{
		try
		{
			Class.forName("oracle.jdbc.driver.OracleDriver");
			if(con==null)
			{
				con = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:XE","system","admin");
			}
		}
		catch(Exception e)
		{
			e.printStackTrace();
		}
		
		return con;
	}
}


FlexibleApp.java
----------------
package com.ihub.www;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.Statement;

public class FlexibleApp 
{
	public static void main(String[] args)throws Exception  
	{
		Connection con = DBConnection.getConnection();
		Statement st = con.createStatement();
		String qry = "select * from student";
		ResultSet rs = st.executeQuery(qry);
		while(rs.next())
		{
			System.out.println(rs.getRow()+" "+rs.getInt(1)+" "+rs.getString(2)+" "+rs.getString(3));
		}
		rs.close();
		st.close();
		con.close();
	}
}

Thin-Client/Fat-Server application 
==================================
Every JDBC application is a thin-client/fat-server application.

Diagram: jdbc8.1

To create thin-client/fat-server application we need to store business logic and persistence logic in the database in the form of stored PL/SQL procedures and functions.

To deal with stored PL/SQL procedures and functions we need to use CallableStatement object.

PL/SQL procedure
================
create or replace procedure first_proc(A IN number,B IN number,C OUT number)
is
begin
C:=A+B;
END;
/

ex:
---
package com.ihub.www;

import java.sql.CallableStatement;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.Types;

public class CallableStmtApp 
{
	public static void main(String[] args)throws Exception  
	{
		Class.forName("oracle.jdbc.driver.OracleDriver");
		Connection con = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:XE","system","admin");
		CallableStatement cst = con.prepareCall("{CALL first_proc(?,?,?)}");
		
		//register OUT parameter 
		cst.registerOutParameter(3, Types.INTEGER);
		
		//set IN parameters
		cst.setInt(1, 10);
		cst.setInt(2, 20);
		
		//execute 
		cst.execute();
		
		//read the data from out parameter 
		int result = cst.getInt(3);
		System.out.println(result);
		
		cst.close();
		con.close();
	} 
}

ex:2
-----

PL/SQL Function 
--------------
create or replace function sum_fun(A number,B number)
return number
is
C number;
begin
C:=A+B;
return C;
END;
/

package com.ihub.www;

import java.sql.CallableStatement;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.Types;

public class CallableStmtApp2 
{
	public static void main(String[] args)throws Exception  
	{
		Class.forName("oracle.jdbc.driver.OracleDriver");
		Connection con = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:XE","system","admin");
		CallableStatement cst = con.prepareCall("{? = call sum_fun(?,?)}");
		
		//register OUT parameter 
		cst.registerOutParameter(1, Types.INTEGER);
		
		//set IN parameters
		cst.setInt(2, 20);
		cst.setInt(3, 30);
		
		//execute 
		cst.execute();
		
		//read the data from out parameter 
		int result = cst.getInt(1);
		System.out.println(result);
		
		cst.close();
		con.close();
	} 
}


Batch Processing 
================
Batch processing is used to declare multiple queries to batch and makes single call to the database.

To add the queries to batch we need to use addBatch() method of Statement object.
ex:
	st.addBatch(query);

To execute the batch we need to use executeBatch() method of Statement object.
ex:
	int[] result = st.executeBatch();


package com.ihub.www;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.Statement;

public class BatchProcessingApp 
{
	public static void main(String[] args)throws Exception  
	{	
		Class.forName("oracle.jdbc.driver.OracleDriver");
		Connection con = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:XE","system","admin");
		Statement st = con.createStatement();
		
		String qry1="insert into student values(104,'ramulu','pune')";
		String qry2="update student set sname='rani' where sno=101";
		String qry3="delete from student where sno=103";
		
		//add the queries to batch
		st.addBatch(qry1);
		st.addBatch(qry2);
		st.addBatch(qry3);
		
		//execute the batch 
		int[] result = st.executeBatch();
		
		int sum=0;
		for(int i : result)
		{
			sum+=i;
		}
		System.out.println("No of Records effected are :"+sum);
		
		st.close();
		con.close();
	}
}

Transaction Management 
======================
Transaction means single unit of work.

We commit if transaction is done.

We rollback if transaction is failed.

Diagram: jdbc8.2

SBI table 
=========
drop table sbi;
create table sbi(accno number(6),accholder varchar2(10), accbal number(8));
insert into sbi values(111111,'venkat',5000);
insert into sbi values(222222,'ranga',6000);
commit;

KOTAK table
============
drop table kotak;
create table kotak(accno number(6),accholder varchar2(10), accbal number(8));
insert into kotak values(100001,'manikanta',80000);
insert into kotak values(200002,'tarun',90000);
commit;



package com.ihub.www;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.Statement;
import java.util.Scanner;

public class TXNManagementApp 
{
	public static void main(String[] args)throws Exception  
	{
		Scanner sc = new Scanner(System.in);
		System.out.println("Enter the source account no :");
		int sno = sc.nextInt();//100001
		
		System.out.println("Enter the destination account no :");
		int dno = sc.nextInt();//111111
		
		System.out.println("Enter the amount to be transfer :");
		int amt = sc.nextInt();
		
		Class.forName("oracle.jdbc.driver.OracleDriver");
		Connection con = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:XE","system","admin");
		
		//set auto commit false 
		con.setAutoCommit(false);
		
		Statement st = con.createStatement();
		
		String qry1 = "update kotak set accbal=accbal-"+amt+" where accno="+sno;
		String qry2 = "update sbi set accbal=accbal+"+amt+" where accno="+dno;
		
		//add the queries to batch
		st.addBatch(qry1);
		st.addBatch(qry2);
		
		//execute the batch 
		int[] result = st.executeBatch();
		
		boolean flag=true;
		for(int i : result)
		{
			if(i==0)
			{
				flag=false;
				break;
			}
		}
		
		if(flag==true)
		{
			System.out.println("Transaction Done Successfully");
			con.commit();
		}
		else
		{
			System.out.println("Transaction Failed");
			con.rollback();
		}
		
		st.close();
		con.close();
	}
}



































































































































